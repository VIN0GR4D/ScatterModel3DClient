Документация по подстилающей поверхности в ПО РЛХ

Оглавление
1. Общее описание
2. Представление на стороне сервера
3. Представление на стороне клиента
4. Согласование координатных систем
5. Взаимодействие клиента и сервера
6. Влияние на точность расчётов


1. Общее описание
Подстилающая поверхность (pplane) - это моделирование отражающей поверхности, расположенной под исследуемым объектом. Она может представлять собой землю, водную поверхность или другую среду, которая влияет на характеристики рассеяния радиоволн. Её учёт необходим для получения более точных результатов в задачах моделирования радиолокационного отражения.

В системе ПО РЛХ подстилающая поверхность:
    Может быть включена или отключена пользователем
    При включении визуализируется в 3D-сцене
    Учитывается в расчётах рассеяния радиоволн на стороне сервера
    Влияет на итоговые характеристики отражения объекта


2. Представление на стороне сервера

2.1 Координатная система
На стороне сервера используется следующая система координат:
    Плоскость XOY расположена горизонтально и параллельна земной поверхности
    Ось Z направлена вверх
    Оси XYZ образуют правую тройку векторов
    Подстилающая поверхность располагается в плоскости Z = 0


2.2 Параметры и настройки
Параметр pplane передаётся серверу в формате JSON:
    {"pplane": true}  // Включение подстилающей поверхности
    {"pplane": false} // Отключение подстилающей поверхности


2.3 Алгоритм обработки
При получении данных сервер определяет наличие подстилающей поверхности через метод:
    if (jsonObject.contains("pplane")) {
        set_ref(jsonObject.value("pplane").toBool());
    }

Функция set_ref устанавливает внутренний флаг наличия подстилающей поверхности:
    void set_ref(bool Ref) { ref = Ref; }


2.4 Влияние на расчёты
В режиме с подстилающей поверхностью (ref = true) алгоритм учитывает:
    Прямое падение и отражение волн от объекта
    Падение волн на объект после отражения от подстилающей поверхности
    Отражение волн от объекта с последующим отражением от подстилающей поверхности
    Многократные переотражения между объектом и поверхностью

Для моделирования этих эффектов используются дополнительные векторы падения и отражения:
    Nin - вектор направления падающей волны
    NinRef - вектор направления падающей волны, отраженной от подстилающей поверхности
    Nout - вектор направления отраженной волны
    NoutRef - вектор направления отраженной волны после взаимодействия с подстилающей поверхностью

Вектор NinRef получается из Nin инверсией компоненты Z:
    NinRef = Nin;
    NinRef.setZ(-Nin.getZ());

Аналогично для NoutRef:
    NoutRef = Nout;
    NoutRef.setZ(-Nout.getZ());


2.5 Математическая модель
При расчётах с подстилающей поверхностью конечное поле рассеяния формируется как сумма четырёх компонентов:
    vEout[iz][iy][ix] += triangles[iTr].PolarDifraction(Nin, Nout, Ein, wave - (1.0 * iy - 0.5 * (countY - 1)) * stepW);
    vEout[iz][iy][ix] += triangles[iTr].PolarDifraction(Nin, NoutRef, Ein, wave - (1.0 * iy - 0.5 * (countY - 1)) * stepW);
    vEout[iz][iy][ix] += triangles[iTr].PolarDifraction(NinRef, Nout, Ein, wave - (1.0 * iy - 0.5 * (countY - 1)) * stepW);
    vEout[iz][iy][ix] += triangles[iTr].PolarDifraction(NinRef, NoutRef, Ein, wave - (1.0 * iy - 0.5 * (countY - 1)) * stepW);

В режиме без подстилающей поверхности (ref = false) учитывается только прямое рассеяние:
    vEout[iz][iy][ix] += triangles[iTr].PolarDifraction(Nin, Nout, Ein, wave - (1.0 * iy - 0.5 * (countY - 1)) * stepW);



3. Представление на стороне клиента

3.1 Координатная система в OpenGL
В клиентском приложении используется OpenGL с системой координат:
    Ось X направлена вправо
    Ось Y направлена вверх
    Ось Z направлена к наблюдателю (из экрана)

3.2 Визуализация подстилающей поверхности
Подстилающая поверхность визуализируется как прозрачная плоскость в методе drawUnderlyingSurface():
void OpenGLWidget::drawUnderlyingSurface() {
    if (!showUnderlyingSurface) return;

    glPushAttrib(GL_ENABLE_BIT | GL_COLOR_BUFFER_BIT);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glDisable(GL_LIGHTING);
    
    // Цвет подстилающей поверхности (светло-серый с прозрачностью)
    glColor4f(0.8f, 0.8f, 0.8f, surfaceAlpha);
    
    // Отрисовка подстилающей поверхности как большого квадрата
    glBegin(GL_QUADS);
    float size = gridSize * 2.0f; // Использовать тот же размер, что и для сетки
    glNormal3f(0.0f, 1.0f, 0.0f); // Нормаль направлена вверх
    glVertex3f(-size, 0.0f, -size);
    glVertex3f(-size, 0.0f, size);
    glVertex3f(size, 0.0f, size);
    glVertex3f(size, 0.0f, -size);
    glEnd();
    
    glPopAttrib();
}


3.3 Управление отображением
Отображение подстилающей поверхности управляется через чекбокс в интерфейсе:
    pplaneCheckBox = new QCheckBox("Включить подстилающую поверхность", frequencyAndPlaneGroupBox);

При изменении состояния чекбокса вызывается метод:
    connect(pplaneCheckBox, &QCheckBox::toggled, openGLWidget, &OpenGLWidget::setUnderlyingSurfaceVisible);

Метод setUnderlyingSurfaceVisible устанавливает флаг видимости:
    void OpenGLWidget::setUnderlyingSurfaceVisible(bool visible) {
        showUnderlyingSurface = visible;
        update();
    }


4. Согласование координатных систем

4.1 Различия в координатных системах
    Сервер: подстилающая поверхность располагается в плоскости Z = 0
    Клиент: подстилающая поверхность отображается в плоскости Z = 0

4.2 Корректное размещение объекта относительно поверхности
Для обеспечения правильного взаиморасположения объекта и подстилающей поверхности необходимо определить нижнюю границу объекта путём поиска минимальной координаты Y:
void OpenGLWidget::ensureObjectAboveSurface() {
    if (vertices.isEmpty()) return;

    // Поиск минимального значения Z объекта
    float minZ = vertices[0].z();
    for (const auto& vertex : vertices) {
        minZ = qMin(minZ, vertex.z());
    }

    // Если минимальное Z меньше 0, корректируем положение объекта
    if (minZ < 0.1f) { // Небольшой буфер для видимого расположения над поверхностью
        QVector3D newPosition = objectPosition;
        newPosition.setZ(objectPosition.z() - minZ + 0.1f);
        setObjectPosition(newPosition);
    }
}


5. Взаимодействие клиента и сервера

5.1 Передача параметров
При отправке данных на сервер клиент включает параметр pplane:
    QJsonObject modelData;
    // ...Другие параметры...
    modelData["pplane"] = pplaneCheckBox->isChecked();

5.2 Синхронизация состояний
Для обеспечения согласованности между расчётами и визуализацией:
    1. Состояние чекбокса pplaneCheckBox определяет:
        Отображение подстилающей поверхности в 3D-сцене
        Включение подстилающей поверхности в расчётах на сервере

    2. При получении результатов:
        Отображаются численные значения
        В случае визуализации портретов учитывается влияние подстилающей поверхности


6. Влияние на точность расчётов
    Включение подстилающей поверхности повышает точность расчётов, но увеличивает время вычислений примерно в 4 раза
    Отключение подстилающей поверхности ускоряет расчёты, но может привести к менее реалистичным результатам для наземных объектов